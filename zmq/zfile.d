/*  =========================================================================
    zfile - helper functions for working with files.

    Copyright (c) the Contributors as noted in the AUTHORS file.
    This file is part of CZMQ, the high-level C binding for 0MQ:
    http://czmq.zeromq.org.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
    =========================================================================
*/

import core.stdc.stdio;
import core.stdc.time;
import core.sys.posix.sys.types;

public import c.zmq.czmq_library;

extern (C):

//  @warning THE FOLLOWING @INTERFACE BLOCK IS AUTO-GENERATED BY ZPROJECT
//  @warning Please edit the model at "api/zfile.api" to make changes.
//  @interface
//  This is a stable class, and may not change except for emergencies. It
//  is provided in stable builds.
//  If file exists, populates properties. CZMQ supports portable symbolic
//  links, which are files with the extension ".ln". A symbolic link is a
//  text file containing one line, the filename of a target file. Reading
//  data from the symbolic link actually reads from the target file. Path
//  may be NULL, in which case it is not used.                           
zfile_t* zfile_new (const(char)* path, const(char)* name);

//  Destroy a file item
void zfile_destroy (zfile_t** self_p);

//  Duplicate a file item, returns a newly constructed item. If the file
//  is null, or memory was exhausted, returns null.                     
//  Caller owns return value and must destroy it when done.
zfile_t* zfile_dup (zfile_t* self);

//  Return file name, remove path if provided
const(char)* zfile_filename (zfile_t* self, const(char)* path);

//  Refresh file properties from disk; this is not done automatically   
//  on access methods, otherwise it is not possible to compare directory
//  snapshots.                                                          
void zfile_restat (zfile_t* self);

//  Return when the file was last modified. If you want this to reflect the
//  current situation, call zfile_restat before checking this property.    
time_t zfile_modified (zfile_t* self);

//  Return the last-known size of the file. If you want this to reflect the
//  current situation, call zfile_restat before checking this property.    
off_t zfile_cursize (zfile_t* self);

//  Return true if the file is a directory. If you want this to reflect   
//  any external changes, call zfile_restat before checking this property.
bool zfile_is_directory (zfile_t* self);

//  Return true if the file is a regular file. If you want this to reflect
//  any external changes, call zfile_restat before checking this property.
bool zfile_is_regular (zfile_t* self);

//  Return true if the file is readable by this process. If you want this to
//  reflect any external changes, call zfile_restat before checking this    
//  property.                                                               
bool zfile_is_readable (zfile_t* self);

//  Return true if the file is writeable by this process. If you want this 
//  to reflect any external changes, call zfile_restat before checking this
//  property.                                                              
bool zfile_is_writeable (zfile_t* self);

//  Check if file has stopped changing and can be safely processed.
//  Updates the file statistics from disk at every call.           
bool zfile_is_stable (zfile_t* self);

//  Return true if the file was changed on disk since the zfile_t object
//  was created, or the last zfile_restat() call made on it.            
bool zfile_has_changed (zfile_t* self);

//  Remove the file from disk
void zfile_remove (zfile_t* self);

//  Open file for reading                             
//  Returns 0 if OK, -1 if not found or not accessible
int zfile_input (zfile_t* self);

//  Open file for writing, creating directory if needed               
//  File is created if necessary; chunks can be written to file at any
//  location. Returns 0 if OK, -1 if error.                           
int zfile_output (zfile_t* self);

//  Read chunk from file at specified position. If this was the last chunk,
//  sets the eof property. Returns a null chunk in case of error.          
//  Caller owns return value and must destroy it when done.
zchunk_t* zfile_read (zfile_t* self, size_t bytes, off_t offset);

//  Returns true if zfile_read() just read the last chunk in the file.
bool zfile_eof (zfile_t* self);

//  Write chunk to file at specified position
//  Return 0 if OK, else -1                  
int zfile_write (zfile_t* self, zchunk_t* chunk, off_t offset);

//  Read next line of text from file. Returns a pointer to the text line,
//  or NULL if there was nothing more to read from the file.             
const(char)* zfile_readln (zfile_t* self);

//  Close file, if open
void zfile_close (zfile_t* self);

//  Return file handle, if opened
FILE* zfile_handle (zfile_t* self);

//  Calculate SHA1 digest for file, using zdigest class.
const(char)* zfile_digest (zfile_t* self);

//  Self test of this class.
void zfile_test (bool verbose);

//  @end

//  @interface
//  These methods are deprecated, and now moved to zsys class.
bool zfile_exists (const(char)* filename);
ssize_t zfile_size (const(char)* filename);
mode_t zfile_mode (const(char)* filename);
int zfile_delete (const(char)* filename);
bool zfile_stable (const(char)* filename);
int zfile_mkdir (const(char)* pathname);
int zfile_rmdir (const(char)* pathname);
void zfile_mode_private ();
void zfile_mode_default ();

//  @end

//  __ZFILE_H_INCLUDED__
